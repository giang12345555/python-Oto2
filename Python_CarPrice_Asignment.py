# -*- coding: utf-8 -*-
"""giua_ki(1)_nhom3 .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JejfvNsjz7UnpGMiEXZM15tocKgP0TCu

# Install / Import library
"""

!pip install pandas
!pip install numpy
!pip install matplotlib
!pip install seaborn
!pip install scikit-learn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import statsmodels.api as sm
sns.set()
from sklearn.neighbors import NearestNeighbors
from sklearn.metrics import confusion_matrix
from sklearn.preprocessing import LabelEncoder,OneHotEncoder
from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score
from sklearn.model_selection import train_test_split

"""# Connect Data"""

from google.colab import files
upload=files.upload()

data= pd.read_csv('CarPrice_Assignment.csv')
data.head()

data

data.info()

feature_data=data.columns
print(f'feature_data:{list(feature_data)}')

uni_car_name = data['CarName'].unique()
print(uni_car_name)

# Tạo một cột mới "CarCompany" chứa tên hãng xe
data['CarCompany'] = data['CarName'].str.split(' ').str[0]

# Hiển thị 5 dòng đầu tiên của DataFrame với cột mới
print(data[['CarName', 'CarCompany']].head())

data.head()

uni_carcpn=data['CarCompany'].unique()
print(uni_carcpn)

data.drop(columns=['CarName'],inplace=True)

data.head()

uni_doornumber= data['doornumber'].unique()
print(uni_doornumber)

def class_doornumber (row):
  if 'two' in row:
    return '2'
  return '4'

data['doornumber'] = data['doornumber'].apply(class_doornumber)

data['doornumber']=data['doornumber'].astype(int)

data.head()

uni_cylin=data['cylindernumber'].unique()
print(uni_cylin)

def class_cylin (row):
  if 'four' in row:
    return '4'
  elif 'five' in row:
    return '5'
  elif 'three' in row:
    return '3'
  elif 'six' in row:
    return '6'
  elif 'twelve' in row:
    return '12'
  elif 'two' in row:
    return '2'
  elif 'eight' in row:
    return '8'

data['cylindernumber'] = data['cylindernumber'].apply(class_cylin)
data.head()

data['cylindernumber']=data['cylindernumber'].astype(int)

data.isnull().sum()

uni_carbody= data['carbody'].unique()
print(uni_carbody)

uni_fueltype=data['fueltype'].unique()
print(uni_fueltype)

uni_dri = data['drivewheel'].unique()
print(uni_dri)

# chuẩn hoá tên gọi
data.rename(columns={'fueltype':'fuel_type','carbody':'car_body','drivewheel':'drive_Wheel','CarCompany':'Car_Company'},inplace=True)

feature_data

# chuẩn hoá tên gọi
data.rename(columns={'wheelbase':'Wheelbase','carlength':'Car_length','carwidth':'Car_width','carheight':'Car_height','curbweight':'Curb_weight','enginetype':'Engine_type','cylindernumber':'Cylinder_number','enginesize':'Engine_size','fuelsystem':'Fuel_system','boreratio':'Bore_ratio','stroke':'Stroke','compressionratio':'Compression_ratio','horsepower':'Horse_power','peakrpm':'Peak_RPM','citympg':'City_MPG','highwaympg':'Highway_MPG','price':'Price','fuel_type':'Fuel_type','car_body':'Car_body','drive_Wheel':'Drive_Wheel','Car_Company':'Car_company','doornumber':'Door_number'},inplace=True)

feature_data=data.columns
print(f'feature_data:{list(feature_data)}')

data.info()

data.describe()

data.shape

"""# Preprocessing &EDA"""

data.isnull().sum()

data.duplicated()

!pip install pandas_profiling==3.6.6

# truc quan du lieu.(nếu lỗi hệ thống  xin bấm chạy lại phần naỳ)
from pandas_profiling.model.alerts import numeric_alerts
numeric_cols= data.select_dtypes(include=[np.number]).columns
for column in numeric_cols:
  plt.figure(figsize=(10,7))
  plt.hist(data[column],edgecolor='k',alpha=0.7)
  plt.title(f'distribution of {column}')
  plt.xlabel(column)
  plt.ylabel('Frequency')
  plt.grid(True)
  plt.show()

data

# xoá cột ID
data.drop(columns=['car_ID'],inplace=True)

data.head()

#thực hiện mã hóa biến phân loại 'doornumber'thành các biến giả (dummy variables) trong tập dữ liệu data.
data=pd.get_dummies(data,columns=['Door_number'])
data.head()

# chuẩn hoá tên gọi
data.rename(columns={'symboling':'Symboling','aspiration':'Aspiration','enginelocation':'Engine_location'},inplace=True)

data.head()

feature_data

# mã hoá dữ liệu
for var in ['Fuel_type','Aspiration',	'Car_body','Drive_Wheel',	'Engine_location','Car_company',	'Engine_type','Fuel_system',]:
  labeler=LabelEncoder()
  scarter_data =labeler.fit_transform(data[var])
  data[var]= scarter_data
data

data.head()

plt.figure(figsize = (20,16),pointsize=15)
sns.heatmap(data.corr(),annot=True,cmap= 'viridis')
#có sự đa cộng tuyến giữa các cột. Car_length,_base, car_width, Curb_weigh

# tạo cột mới với tỉ lệ giữa chiều rộng và chiều cao
data['Car_width_to_height_ratio'] = data['Car_width'] / data['Car_height']

data.head()

data.drop(columns=['Car_width','Car_height'],inplace=True)

# Tính trung bình công suất cho từng loại động cơ
average_horsepower_by_engine = data.groupby('Engine_type')['Horse_power'].mean().reset_index()
average_horsepower_by_engine['Horse_power'] = average_horsepower_by_engine['Horse_power'].round(2)

# Đổi tên cột để phân biệt với cột Horse_power gốc
average_horsepower_by_engine = average_horsepower_by_engine.rename(columns={'Horse_power': 'Avg_Horse_power'})

# Kết hợp lại với dữ liệu gốc
data = data.merge(average_horsepower_by_engine, on='Engine_type', how='left')

data.head()

data.drop(columns=['Engine_type','Horse_power'],inplace=True)

# tạo cột tính tỉ lệ giữa chiều dài cơ sở  và chiều dài xe, chiều dài cơ sở và trọng lượng hạn chế ,Kích thước động cơ và trọng lượng hạn chế
data['Wheel_base_to_Car_length_Ratio'] = data['Wheelbase'] / data['Car_length']
data['Wheel_base_to_Curb_weight_Ratio'] = data['Wheelbase'] / data['Curb_weight']
data['Engine_size_to_Curb_weight_Ratio'] = data['Engine_size'] / data['Curb_weight']

# xoá các cột cũ
data.drop(columns=['Wheelbase','Car_length','Curb_weight','Engine_size'],inplace=True)

# xoá các cột có mối tương quan yếu
data.drop(columns=['City_MPG','Highway_MPG'],inplace=True)

data.drop(columns=['Wheel_base_to_Curb_weight_Ratio'],inplace=True)

plt.figure(figsize=(15,10))
sns.heatmap(data.corr(),annot=True,cmap= 'viridis')
# có sự đa động tuyến tại cột. Engine_size_to_Curb_weight_Ratio và Cylinder_number. thực hiện giảm chiều PCA

from sklearn.decomposition import PCA

# Khởi tạo PCA với số thành phần chính bạn muốn giữ lại
pca = PCA(n_components=1)

# Fit và biến đổi dữ liệu
X_pca = pca.fit_transform(data)

# Xem xét tỷ lệ phần trăm phương sai được bao quát bởi từng thành phần chính
explained_variance = pca.explained_variance_ratio_

# In ra tỷ lệ phần trăm phương sai
print(explained_variance)

y = data['Price']
featureName1 =  data.columns.difference(['Price'])
print(f'featureName: {list(featureName1)}')

X = data[featureName1]

X

Var = sm.OLS(y,sm.add_constant(X))
Var_resul =Var.fit()
print(Var_resul.summary())

#loại bỏ các mẫu dữ liệu không gia tri với P>|t| >0.05
X.drop(columns=['Aspiration','Car_width_to_height_ratio','Compression_ratio','Door_number_2','Door_number_4','Stroke','Symboling','Wheel_base_to_Car_length_Ratio'],inplace=True)

X

Var = sm.OLS(y,sm.add_constant(X))
Var_resul =Var.fit()
print(Var_resul.summary())

#xoá dữ liệu không giá trên cột X
X.drop(columns=['Peak_RPM','Car_body'],inplace=True)

X

Var = sm.OLS(y,sm.add_constant(X))
Var_resul =Var.fit()
print(Var_resul.summary())
# con lại Avg_Horse_power và Fuel_type vẫn có ảnh hưởng đến giá trị nên có thể giữ lại

plt.figure(figsize=(10,7))
sns.countplot(x= 'Avg_Horse_power',data=data)
plt.show()

data['Avg_Horse_power'].min()

data['Avg_Horse_power'].max()



# chuẩn hoá dữ liệu giảm sai số
power_bin = [ 93.65, 95.5, 109.5, 110.4, 146.0, 288]
power_bin.sort()  # Sắp xếp theo thứ tự tăng dần
power_label = [ '93.65-95.5', '95.51-109.5', '109.51-110.4', '110.41-146.0', '146.01+']
data['Power_Group'] = pd.cut(data['Avg_Horse_power'], bins=power_bin, labels=power_label)

plt.figure(figsize=(10,7))
sns.countplot(x= 'Power_Group',data=data)
plt.show()

power_z_core=(data['Avg_Horse_power']-data['Avg_Horse_power'].mean())/data['Avg_Horse_power'].std() #score cho biết mức độ sai khác giữa giá trị mẫu và trung bình, thể hiện trong đơn vị độ lệch chuẩn.
threshold=3
power_oulire_mask= np.abs(power_z_core)>threshold
power_oulire_mask

#thực hiện việc loại bỏ các mẫu dữ liệu được đánh dấu là outliers
data=data[~power_oulire_mask]

plt.figure(figsize=(10,7))
sns.countplot(x= 'Avg_Horse_power',data=data)
plt.show()

plt.figure(figsize=(15,10))
sns.countplot(x= 'Bore_ratio',data=data)
plt.show()

plt.figure(figsize=(15,10))
sns.countplot(x= 'Cylinder_number',data=data)
plt.show()
## dữ liệu đã outliers

# chọn lại dữ liệu tập tin có các cột ảnh hưởng giá xe
data_1= data[['Avg_Horse_power','Bore_ratio','Car_company','Cylinder_number','Drive_Wheel','Engine_location','Engine_size_to_Curb_weight_Ratio','Fuel_system','Fuel_type','Price']]

data_1

plt.figure(figsize=(15,10))
sns.heatmap(data_1.corr(),annot=True,cmap= 'viridis')
# thực hiện PCA đối với tập data_1

from sklearn.decomposition import PCA

# Khởi tạo PCA với số thành phần chính bạn muốn giữ lại
pca = PCA(n_components=1)

# Fit và biến đổi dữ liệu
X_1_pca = pca.fit_transform(data_1)

# Xem xét tỷ lệ phần trăm phương sai được bao quát bởi từng thành phần chính
explained_variance_1 = pca.explained_variance_ratio_

# In ra tỷ lệ phần trăm phương sai
print(explained_variance_1)
# tỉ lệ tăng lên đáng kể. mô hình giữ lại hầu như tất cả mà không mất giữ liệu

"""# Split dataset into training / testing sets & Normalize (if needed)"""

y

X

print('X',X.size)
print('y',y.size)

X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=0.2,random_state=42)

X_train

print("X_train",X_train.size)
print("X_test",X_test.size)

print("y_train",y_train.size)
print("y_test",y_test.size)

"""# Trainning"""

from sklearn.decomposition import PCA
from sklearn.linear_model import LinearRegression
n_comp = 9
# Khởi tạo PCA
pca = PCA(n_components=n_comp)

# Biến đổi dữ liệu huấn luyện
X_train_pca = pca.fit_transform(X_train)
X_test_pca = pca.transform(X_test)
# Khởi tạo mô hình hồi quy tuyến tính
linear_model = LinearRegression()

# Huấn luyện mô hình trên dữ liệu đã biến đổi bằng PCA
linear_model.fit(X_train_pca, y_train)

from sklearn.neighbors import KNeighborsRegressor
knn_model = KNeighborsRegressor()
knn_model.fit(X_train_pca,y_train)

from sklearn.ensemble import RandomForestRegressor
forest_model = RandomForestRegressor(random_state=42)
forest_model.fit(X_train_pca,y_train)

from sklearn.tree import DecisionTreeRegressor
tree_model = DecisionTreeRegressor(random_state=42)
tree_model.fit(X_train_pca,y_train)

"""# Evaluation"""

# Dự đoán y trên tập X_test
from sklearn.linear_model import LinearRegression
linear_model_y_pred =linear_model.predict(X_test_pca)
knn_y_pred = knn_model.predict(X_test_pca)
forest_model_y_pred = forest_model.predict(X_test_pca)
tree_model_y_pred = tree_model.predict(X_test_pca)

linear_model_y_pred

knn_y_pred

forest_model_y_pred

tree_model_y_pred

# Đánh giá mô hình (có thể sử dụng các phương pháp đánh giá phù hợp)
from sklearn.metrics import mean_squared_error, r2_score

print('Mean squared error:%.2f'%
      mean_squared_error(y_test, linear_model.predict(X_test_pca)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, linear_model.predict(X_test_pca)))

print('Mean squared error:%.2f'%
      mean_squared_error(y_test, knn_model.predict(X_test_pca)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, knn_model.predict(X_test_pca)))

print('Mean squared error:%.2f'%
      mean_squared_error(y_test, forest_model.predict(X_test_pca)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, forest_model.predict(X_test_pca)))

print('Mean squared error:%.2f'%
      mean_squared_error(y_test, tree_model.predict(X_test_pca)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, tree_model.predict(X_test_pca)))

"""# chạy mô hình không phải pca đối các mô hình knn,random forest,tree. xem thử kết quả"""

from sklearn.neighbors import KNeighborsRegressor
knn_model = KNeighborsRegressor()
knn_model.fit(X_train,y_train)

from sklearn.ensemble import RandomForestRegressor
forest_model = RandomForestRegressor(random_state=42)
forest_model.fit(X_train,y_train)

from sklearn.tree import DecisionTreeRegressor
tree_model = DecisionTreeRegressor(random_state=42)
tree_model.fit(X_train,y_train)

"""Evaluation"""

knn_y_pred_1 = knn_model.predict(X_test)
forest_model_y_pred_1 = forest_model.predict(X_test)
tree_model_y_pred_1 = tree_model.predict(X_test)

knn_y_pred_1

forest_model_y_pred_1

tree_model_y_pred_1

## Đánh giá mô hình (có thể sử dụng các phương pháp đánh giá phù hợp)
print('Mean squared error:%.2f'%
      mean_squared_error(y_test, knn_model.predict(X_test)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, knn_model.predict(X_test)))

print('Mean squared error:%.2f'%
      mean_squared_error(y_test, forest_model.predict(X_test)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, forest_model.predict(X_test)))

print('Mean squared error:%.2f'%
      mean_squared_error(y_test, tree_model.predict(X_test)))
print('Coefficient of determination:%.2f'%
      r2_score(y_test, tree_model.predict(X_test)))

"""# đánh gía mô hình

Khi sử dụng PCA (n_comp=9):

Mô hình K-Nearest Neighbors (knn_model) có MSE là 22204393.80 và R-squared là 0.72.
Mô hình Random Forest (forest_model) có MSE là 9146479.98 và R-squared là 0.88.
Mô hình Decision Tree (tree_model) có MSE là 12558324.75 và R-squared là 0.84.

Khi không sử dụng PCA:

Mô hình K-Nearest Neighbors (knn_model) có MSE là 22193512.55 và R-squared là 0.72.
Mô hình Random Forest (forest_model) có MSE là 4837847.36 và R-squared là 0.94.
Mô hình Decision Tree (tree_model) có MSE là 15533622.02 và R-squared là 0.80.

 Dựa trên kết quả này:

  Mô hình K-Nearest Neighbors có hiệu suất tương tự khi sử dụng PCA hoặc không sử dụng PCA, nghĩa là PCA không cải thiện hiệu suất cho mô hình này.

Mô hình Random Forest và Decision Tree đạt hiệu suất tốt hơn khi không sử dụng PCA. Điều này có thể xảy ra vì PCA loại bỏ một số thông tin từ dữ liệu ban đầu và có thể dẫn đến mất mát thông tin quan trọng đối với mô hình cây quyết định.

**MÔ HÌNH TỐT NHẤT LAD RANDOM FOREST KHÔNG PCA VỚI TỈ LỆ CHÍNH XÁC CAO 94% VÀ CÓ PHƯƠNG SAI THẤP NHẤT TRONG SỐ CÁC MODEL**

## TRẢ LỜI YÊU CẦU ĐỀ 1
"""

data_1

"""Yêu cầu : Các thông số nào của ô tô sẽ ảnh hưởng đến giá của chiếc ô tô đó?
các thông số ảnh hưởng đến giá ô tô là:
- Avg_Horse_power (Công suất trung bình của động cơ): các xe có công suất động cơ mạnh hơn có giá đắt hơn. Công suất cao thường liên quan đến hiệu suất tốt hơn, nhưng cũng có thể tăng giá thành sản xuất.
- Bore_ratio (Tỷ lệ đường kính piston của động cơ): Tỷ lệ bore ratio ảnh hưởng đến công suất và hiệu suất động cơ. Nó ảnh hưởng đến việc chọn loại nhiên liệu và hệ thống cung cấp nhiên liệu, và từ đó tác động đến giá xe.
- Car_company (Hãng sản xuất xe): Hãng sản xuất xe là một yếu tố quan trọng. Mỗi hãng thường có danh tiếng, phong cách thiết kế, và định vị riêng. Xe từ các hãng nổi tiếng hoặc cao cấp có giá đắt hơn do hình ảnh thương hiệu.
- Cylinder_number (Số xi-lanh của động cơ): Số lượng xi-lanh ảnh hưởng đến công suất và hiệu suất động cơ. Xe có động cơ nhiều xi-lanh có giá cao hơn vì nó cung cấp hiệu suất tốt hơn.
- Engine_location (Vị trí đặt động cơ): Vị trí đặt động cơ cũng ảnh hưởng đến giá. Xe có động cơ đặt ở vị trí đặc biệt (ví dụ: động cơ sau) có thể có giá đắt hơn do yêu cầu thiết kế và công nghệ đặc biệt.
- Drive_Wheel: Loại hệ thống dẫn động có thể ảnh hưởng đến giá xe. Ví dụ, các xe có hệ thống dẫn động cầu sau (RWD) thường có giá đắt hơn so với xe dẫn động cầu trước (FWD) vì RWD thường đi kèm với hiệu suất và độ bền tốt hơn.
- Engine_size_to_Curb_weight_Ratio: Tỷ lệ kích thước động cơ so với trọng lượng xe có thể ảnh hưởng đến hiệu suất và tiết kiệm nhiên liệu. Xe có tỷ lệ này cao hơn có thể có giá đắt hơn, nhưng cung cấp hiệu suất tốt hơn.
- Fuel_system và Fuel_type: Loại nhiên liệu và hệ thống cung cấp nhiên liệu (Fuel system) cũng có ảnh hưởng đáng kể đến giá xe. Ví dụ, xe sử dụng nhiên liệu cao cấp hoặc có hệ thống cung cấp nhiên liệu hiệu quả có thể có giá đắt hơn.
"""

#Biểu đồ mối quan hệ
plt.figure(figsize=(15,10))
sns.heatmap(data_1.corr(),annot=True,cmap= 'viridis')

"""**Đâu là những yếu tố quan trọng để định giá ô tô?**
bán xe tại Mỹ, có một số yếu tố quan trọng bạn nên quan tâm hơn dựa trên thị trường và sở thích của khách hàng Mỹ. Dưới đây là một số yếu tố quan trọng:
- **Kích thước động cơ và hiệu suất**: Người Mỹ thường có niềm đam mê với công suất và hiệu suất của xe. Họ thích có nhiều lựa chọn về động cơ mạnh mẽ. Do đó, cung cấp các phiên bản xe với động cơ có công suất lớn có thể hấp dẫn khách hàng.
- **Kiểu dáng và thiết kế**: Xe hơi phải có ngoại hình và thiết kế phù hợp với thị trường Mỹ. Thị trường Mỹ thích các loại xe như SUVs, xe bán tải và xe sedan.
- **Tính tiện ích và an toàn**: Một yếu tố quan trọng khác là tính tiện ích và an toàn. Khách hàng Mỹ quan tâm đến tính năng an toàn và tiện nghi như hệ thống thông tin giải trí, hệ thống đỗ xe tự động, và tích hợp với điện thoại thông minh.
- **Mức tiêu thụ nhiên liệu:** Mức tiêu thụ nhiên liệu là một yếu tố quan trọng. Khách hàng Mỹ thường đi xa và cần xe có khả năng tiết kiệm nhiên liệu.
- **Giá cả và sự cạnh tranh:** Thị trường Mỹ rất cạnh tranh, vì vậy giá cả cũng quan trọng. Đảm bảo rằng giá của bạn cạnh tranh với các đối thủ trong cùng phân khúc.
-** Dịch vụ hậu mãi và bảo hành:** Một chính sách bảo hành và dịch vụ hậu mãi tốt có thể là yếu tố quyết định khi khách hàng Mỹ quyết định mua xe.
- Hệ thống phân phối và tiếp thị: Xây dựng một hệ thống phân phối hiệu quả và chiến dịch tiếp thị tốt là rất quan trọng để tiếp cận khách hàng.

**loại bỏ một số yếu tố không liên quan đến giá sản xuất ô tô .dựa vào biểu đồ mối quan hệ ta có thể thấy được:**
- **Cylinder_number**: có chỉ số quan hệ khá cao. Số lượng xi-lanh ảnh hưởng đến công suất và hiệu suất động cơ. nên kinh doanh các loại động cơ có số xilanh lớn
- **Avg_Horse_power**: Công suất trung bình của động cơ. ảnh hưởng đến hiệu xuất động cơ . nên chọn các loại cộng cơ công suất trung bình lớn.
-Bore_ratio: Tỷ lệ bore ratio ảnh hưởng đến công suất và hiệu suất động cơ. chọn một tỉ lệ tốt sẽ tạo động cơ mạnh mẽ.
- **Engine_location (Vị trí đặt động cơ)**: Thị trường Mỹ thích các loại xe như SUVs, xe bán tải và xe sedan. việc đặt động cơ ở trước sẽ phù hợp với thẩm mỹ của người mỹ.
- **Drive_Wheel(Loại hệ thống dẫn động )**: tuỳ vào khí hậu bên mỹ chungs ta có thể chọn theo địa lý, cụ thể:
1. **Khí hậu ấm áp, ẩm ướt hoặc mùa hè nóng:** Trong các khu vực có mùa hè nóng, như miền Nam hoặc miền Đông, FWD (Front-Wheel Drive) có thể là lựa chọn tốt. Trọng lượng động cơ ở phía trước giúp cải thiện độ bám đường trong điều kiện ẩm ướt và giúp bạn nhanh chóng đối phó với mưa.
2. **Miền Bắc và miền núi:**  ở khu vực có mùa đông lạnh và tuyết phủ, hệ thống dẫn động 4WD hoặc AWD (All-Wheel Drive) có thể là lựa chọn tốt. Chúng giúp cải thiện độ bám đường và kiểm soát trong điều kiện trơn trượt, như tuyết.
3. **Miền núi hoặc off-road**: ở khu vực có địa hình đa dạng hoặc thường xuyên lái xe ngoài đường, hệ thống dẫn động 4WD hoặc AWD là lựa chọn tốt.
4. **Khu vực đô thị và môi trường chung**: Trong các khu vực đô thị, FWD, RWD (Rear-Wheel Drive) hoặc AWD có thể phù hợp tùy thuộc vào ưu tiên cá nhân, vì đường phố thường được duy trì tốt và không cần quá nhiều khả năng off-road.
-  **Engine_size_to_Curb_weight_Ratio:** tỷ lệ kích thước động cơ so với trọng lượng xe. dựa trên biểu đồ thì ta có thể thấy trọng lượng xe càng nhẹ kích thước động cơ càng lớn thì càng có thể tăng công suất và mã lực. nên chọn tỉ lệ lớn đối với tỉ lệ này trong thị trường bên Mỹ
- **Fuel_system và Fuel_type:** Loại nhiên liệu và hệ thống cung cấp nhiên liệu (Fuel system): dựa theo yêu cầu của thị trường mỹ chúng ta cần chọn hệ thống ưu tiên tiết kiệm nhiên liệu nhưng vẫn đảm bảo hệ thống tốt. đảm bảo đi đường dài



"""